<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no"/>
  <title>Cloze Cards Reviewer ‚Äî JSON ‚Üí Visual ‚Üí Save/Discard</title>
  <style>
    :root{
      --bg:#0f1115; --panel:#171a21; --surface:#1e222b; --muted:#96a0af; --text:#e7eaf0;
      --accent:#9b87fd; --accent-weak:#b6a9ff; --good:#2ecc71; --bad:#e74c3c; --warn:#f39c12;
      --ring:0 0 0 2px rgba(155,135,253,.35);
      --radius:14px; --shadow:0 10px 30px rgba(0,0,0,.35);
      --code:#0b0d12;
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--text);font:16px/1.35 system-ui,Segoe UI,Roboto,Inter,Helvetica,Arial}
    /* This class is now handled via JS inline styles for better locking */
    body.modalOpen{ } 
    a{color:var(--accent);text-decoration:none}
    a:hover{text-decoration:underline}
    /* Prevent double-tap zoom on interactive controls */
    html, body { touch-action: manipulation; -webkit-overflow-scrolling: touch; }
    button, .btn, .segbtn, a, [role="button"] {
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }
    .wrap{max-width:880px;margin:0 auto;padding:16px}
    header{
      position:sticky;top:0;z-index:5;background:linear-gradient(180deg,var(--bg),rgba(15,17,21,.8));
      backdrop-filter: blur(8px); border-bottom:1px solid #262b35;
    }
    .toolbar{display:flex;flex-wrap:wrap;gap:10px;align-items:center;padding:12px}
    .toolbar .title{font-weight:700;font-size:18px;margin-right:auto}
    .btn{
      border:1px solid #2a3140;background:var(--surface);color:var(--text);
      padding:9px 12px;border-radius:10px;cursor:pointer;box-shadow:var(--shadow);
      display: inline-flex; align-items: center; justify-content: center; gap: 6px;
    }
    .btn:focus{outline:none;box-shadow:var(--ring)}
    .btn.primary{background:var(--accent);border-color:transparent;color:#0b0d12}
    .btn.good{background:var(--good);border-color:transparent;color:#0b0d12}
    .btn.bad{background:#ff6b6b;border-color:transparent;color:#0b0d12}
    .btn.warn{background:var(--warn);border-color:transparent;color:#0b0d12}
    .btn.blue { background:#4a90e2; border-color:transparent; color:#0b0d12 }
    .btn.red { background:#e74c3c; border-color:transparent; color:#0b0d12 }
    .btn.green { background:#2ecc71; border-color:transparent; color:#0b0d12 }
    .seg{display:flex;gap:6px;background:var(--panel);padding:6px;border-radius:10px;border:1px solid #293042}
    .seg .segbtn{
      background:transparent;border:0;color:var(--muted);padding:8px 12px;border-radius:8px;cursor:pointer
    }
    .seg .segbtn.active{background:var(--surface);color:var(--text);box-shadow:var(--ring)}
    .searchRow{display:flex;gap:10px;flex-wrap:wrap;width:100%}
    .input, textarea{
      background:#141821;border:1px solid #2b3243;color:var(--text);
      padding:10px 12px;border-radius:10px;box-shadow:inset 0 0 0 1px rgba(0,0,0,.2)
    }
    .input:focus, textarea:focus{outline:none;box-shadow:var(--ring)}
    textarea{width:100%;min-height:160px;resize:vertical}
    .cardlist{display:flex;flex-direction:column;gap:14px;margin-top:14px}
    .card{
      position:relative;
      background:var(--surface);border:1px solid #2b3243;border-radius:var(--radius);padding:12px;
      box-shadow:var(--shadow);display:flex;flex-direction:column;gap:10px
    }
    .statusBar{
      margin:-12px -12px 8px -12px;
      padding:4px 10px;
      border-top-left-radius:var(--radius);border-top-right-radius:var(--radius);
      display:flex;align-items:center;
    }
    .statusTitle{
      flex:1;text-align:center;font-weight:700;letter-spacing:.03em;font-size:13px;color:#0b0d12;
    }
    .status-new{background:linear-gradient(180deg,#f7c948,#996c00)}
    .status-saved{background:linear-gradient(180deg,#2ecc71,#0e8f49)}
    .status-discarded{background:linear-gradient(180deg,#ff6b6b,#b02a2a)}
    .clozeTop{
      margin-left:auto;display:flex;align-items:center;gap:6px;
      background:#00000022;border:1px solid #00000033;border-radius:999px;padding:2px 6px;
    }
    .clozeTop .miniBtn{
      border:1px solid #00000055;background:#00000033;color:#ffffff;border-radius:8px;
      padding:2px 6px;cursor:pointer;font-size:12px;line-height:1
    }
    .clozeTop .indicator{font:12px/1.2 ui-monospace,SFMono,Menlo,Consolas;color:#ffffffcc}
    .meta{display:flex;align-items:center;gap:8px;color:var(--muted);font-size:12px}
    .tags{display:flex;flex-wrap:wrap;gap:6px}
    .notehtml{line-height:1.55;font-size:16px}
    .notehtml .cloze, .notehtml .cloze b, .notehtml .cloze i, .notehtml .cloze u{
      color:#0b0d12;background:var(--accent);padding:1px 5px;border-radius:6px;font-weight:700
    }
    .notehtml .cloze.sibling, .notehtml .cloze.sibling b, .notehtml .cloze.sibling i, .notehtml .cloze.sibling u{
      background:transparent;color:var(--accent);padding:0;border-radius:0
    }
    .notehtml .ghost{
      color:var(--accent-weak);border:1px dashed #3c3f55;padding:1px 5px;border-radius:6px;opacity:.9
    }
    .row{display:flex;gap:8px;flex-wrap:wrap}
    .row .btn.small{padding:6px 9px;border-radius:8px;font-size:13px}
    .row.right{margin-left:auto}
    .toolbarStats{margin-left:auto; display:flex; align-items:center; gap:8px; color:var(--muted); font-weight:600;}
    .toolbarStats .pill{margin:0; font-weight:600;}
    .pill{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;background:#151925;border:1px solid #2b3243;color:#cbd3df;font-size:13px}
    .hidden{display:none !important}

    .briefCard{white-space:pre-wrap;padding:10px;border-radius:10px;border:1px solid #2b3243;background:#121621;line-height:1.4;}
    .mutedLabel{color:var(--muted);font-size:13px;}
    .briefOverlay{margin-top:12px;padding:14px;border:1px solid #2b3243;border-radius:12px;background:var(--surface);box-shadow:var(--shadow);display:flex;flex-direction:column;gap:12px;}
    .briefOverlay .briefCard{min-height:80px;}
    .briefOverlay .row{justify-content:flex-end;gap:8px;flex-wrap:wrap;}
    
    .modalBackdrop{
      position:fixed;inset:0;background:rgba(0,0,0,.55);
      display:none;
      /* Default: Center vertically (Desktop) */
      align-items:center;
      justify-content:center;z-index:20;
      backdrop-filter: blur(6px);
      overflow-y: auto; 
      -webkit-overflow-scrolling: touch;
    }
    .modal{
      width:min(760px,94vw);
      max-height: min(90vh, 800px);
      display: flex; flex-direction: column;
      background:var(--panel);border:1px solid #2b3243;border-radius:16px;box-shadow:var(--shadow);padding:16px;
      transform: translateZ(0);
    }
    .modalContent {
      overflow-y: auto;
      overscroll-behavior: contain;
    }
    .modal header{border:0;background:transparent;flex-shrink:0;padding-bottom:8px}
    .f1{flex:1}
    .hr{height:1px;background:#2b3243;margin:10px 0;border-radius:1px; flex-shrink: 0;}

    /* ---- MOBILE ONLY OVERRIDES ---- */
    @media (max-width: 600px) {
      /* Align modals to the TOP on phone screens */
      .modalBackdrop {
        align-items: flex-start;
        padding-top: 15px; /* Add space from top of screen */
      }
      /* Reduce text area height so keyboard doesn't hide buttons */
      #editArea {
        min-height: 180px !important;
      }
      /* Allow modal to take up more width on phones */
      .modal {
        width: 96vw;
      }
    }
  </style>
</head>
<body>
<header>
  <div class="toolbar wrap">
    <div class="title">Cloze Cards Reviewer</div>
    <div class="seg" role="tablist" aria-label="Views">
      <button class="segbtn active" data-view="all">All</button>
      <button class="segbtn" data-view="new">New</button>
      <button class="segbtn" data-view="saved">Saved</button>
      <button class="segbtn" data-view="discarded">Discarded</button>
    </div>
    <button class="btn" id="soloBtn" title="One-at-a-time viewer (optional)">Solo View</button>
    <div class="searchRow">
      <input class="input" id="search" placeholder="Search">
      <button class="btn" id="toggleTagsBtn" title="Show/Hide tags">Show Tags</button>
    </div>
    <div class="row">
      <button class="btn" id="copyAllBtn" title="Copy all visible" style="display:none;">Copy Visible</button>
      <button class="btn" id="apkgBtn" title="Download .apkg" style="display:none;">Download APKG</button>
      <button class="btn" id="jsonExportBtn" title="Download or copy combined JSON" style="display:none;">JSON Export</button>
      <button class="btn" id="copyDiffBtn" title="Copy edited cards diff" style="display:none;">Copy DIFF</button>
      <button class="btn warn" id="nukeBtn" title="Clear local data">Reset</button>
      <button class="btn red" id="deleteDiscardedBtn" title="Delete all discarded cards" style="display:none;">Delete Discarded (<span id="discardCountLabel">0</span>)</button>
      <div class="toolbarStats">
        <span id="countLabel">0</span> cards
      </div>
    </div>
  </div>
</header>

<main class="wrap">
  <section id="ingest">
    <p class="muted mini">Paste JSON produced by your chatbot and click <b>Load JSON</b>. Accepted shapes:
      <code class="pill">["..."]</code>,
      <code class="pill">[{ "content": "..." }]</code>,
      <code class="pill">[{ "html": "...", "tags": ["‚Ä¶"], "id": "‚Ä¶" }]</code>.
      Each string/object must contain <b>cloze HTML</b> like <code>{{c1::answer}}</code>.
    </p>
    <textarea id="jsonInput" placeholder='[
  "What is the capital of Australia?<br><br>{{c1::Canberra}}",
  {"content": "The three branches are {{c1::executive}}, {{c1::legislative}}, and {{c1::judicial}}.", "tags":["civics"]},
  {"html":"{{c1::Jupiter}} is the largest planet.", "id":"note-42", "tags":["astro","giants"]}
]'></textarea>
    <div class="row" style="margin-top:10px;">
      <button class="btn primary" id="loadBtn">Load JSON</button>
    </div>
  </section>

  <section id="listArea" class="hidden">
    <div id="cards" class="cardlist" aria-live="polite"></div>
  </section>

  <section id="appendArea" class="hidden" style="margin-top:28px;">
    <div class="hr"></div>
    <h3 style="margin:0 0 8px 0;">Add More Cards</h3>
    <textarea id="appendInput" placeholder='["Another {{c1::card}}", {"content":"More {{c1::items}}"}]'></textarea>
    <div class="row" style="margin-top:10px;">
      <button class="btn primary" id="appendBtn">Append JSON</button>
    </div>
  </section>
</main>

<!-- Solo modal -->
<div class="modalBackdrop" id="soloBack" aria-hidden="true">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="soloTitle">
    <header class="row" style="gap:10px;">
      <div id="soloTitle" class="f1">Solo View</div>
      <button class="btn" id="soloPrev"><span>‚Üê</span> Prev</button>
      <button class="btn" id="soloNext">Next <span>‚Üí</span></button>
      <button class="btn bad" id="soloClose">Close</button>
    </header>
    <div class="hr"></div>
    <div class="modalContent">
        <div id="soloCard" class="card"></div>
        <div class="row" style="margin-top:8px">
        <button class="btn good small" id="soloSave">‚≠ê Save</button>
        <button class="btn small" id="soloCopy">üìã Copy</button>
        <button class="btn small" id="soloEdit">‚úèÔ∏è Edit</button>
        <button class="btn bad small" id="soloDiscard">üóëÔ∏è Discard</button>
        </div>
    </div>
  </div>
</div>

<script>
(() => {
  const el = sel => document.querySelector(sel);
  const els = sel => Array.from(document.querySelectorAll(sel));
  const storeKey = "cloze-reviewer-v1";
  const tagsKey = "cloze-reviewer-tags-visible";
  let notes = [];
  let view = "all";
  let searchTerm = "";
  let lastRendered = [];
  let soloIndex = 0;
  const uiState = {};
  let lastInteractedCardId = null;
  let tagsVisible = (() => {
    try { const v = localStorage.getItem(tagsKey); return v === null ? false : v === "1"; }
    catch { return false; }
  })();

  // ---- Kill double-tap zoom (iOS Safari & friends) but keep rapid taps working
  (function preventDoubleTapZoom(){
    const isEditable = el => !!(el && el.closest('input, textarea, [contenteditable="true"]'));
    document.addEventListener('dblclick', (e) => {
      if (isEditable(e.target)) return;
      e.preventDefault();
    }, { passive: false, capture: true });
    let lastTouchEnd = 0;
    document.addEventListener('touchend', (e) => {
      if (e.touches && e.touches.length) return;
      if (isEditable(e.target)) return;
      const now = Date.now();
      if (now - lastTouchEnd <= 300) {
        e.preventDefault();
        const target = e.target.closest('button, .btn, .segbtn, a, [role="button"]');
        if (target) target.click();
      }
      lastTouchEnd = now;
    }, { passive: false, capture: true });
  })();

  // --- FIX: Stronger Scroll Lock for Modals ---
  let savedScrollY = 0;

  function openModalBackdrop(div){
    // 1. Record where we are
    savedScrollY = window.scrollY;
    
    // 2. Physically lock the body so it CANNOT scroll.
    // This prevents the input cursor from misaligning with the view.
    document.body.style.position = 'fixed';
    document.body.style.top = `-${savedScrollY}px`;
    document.body.style.width = '100%';
    document.body.style.overflow = 'hidden';

    // 3. Show modal
    div.style.display = "flex"; 
    div.setAttribute("aria-hidden","false");
  }

  function closeModalBackdrop(div){
    // 1. Hide modal
    div.style.display = "none"; 
    div.setAttribute("aria-hidden","true");

    // 2. Unlock body
    document.body.style.position = '';
    document.body.style.top = '';
    document.body.style.width = '';
    document.body.style.overflow = '';

    // 3. Instant jump back to original position
    window.scrollTo(0, savedScrollY);
  }

  try {
    const raw = localStorage.getItem(storeKey);
    if (raw) { const parsed = JSON.parse(raw); if (Array.isArray(parsed)) notes = parsed; }
  } catch {}
  if (!Array.isArray(notes)) notes = [];
  notes.forEach(n => {
    if (n && typeof n === "object" && typeof n.originalHtml !== "string") {
      n.originalHtml = n.html;
    }
  });

  function uid(){ return "n_" + Math.random().toString(36).slice(2,10) + Date.now().toString(36); }
  function save(){ localStorage.setItem(storeKey, JSON.stringify(notes)); }
  function trimHtml(s){ return (s||"").toString().trim(); }
  function escapeHtml(s){ return s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }
  function getClozeNumbers(html){ const set=new Set(); const re=/{{c(\d+)::/g; let m; while((m=re.exec(html))){ set.add(parseInt(m[1],10)); } return Array.from(set).sort((a,b)=>a-b); }
  function normalizeBreaks(str){
    const escaped = escapeHtml(str);
    return escaped
      .replace(/\r\n?/g, "\n")
      .replace(/&lt;br\s*\/?&gt;/gi, "<br>")
      .replace(/\n/g, "<br>");
  }
  function renderClozeTarget(html, targetNum, hideTarget){
    if (!targetNum) return trimHtml(html);
    const re = /{{c(\d+)::([^]*?)(?:::([^]*?))?}}/g;
    return trimHtml(html).replace(re, (_, num, ans, hint) => {
      const n = parseInt(num,10);
      const hintText = hint ? normalizeBreaks(hint) : "‚Ä¶";
      const ansEsc = normalizeBreaks(ans);
      if (n === targetNum){
        return hideTarget
          ? `<span class="ghost" data-c="${n}">[${hintText}]</span>`
          : `<span class="cloze active" data-c="${n}">${ansEsc}</span>`;
      } else {
        return `<span class="cloze sibling" data-c="${n}">${ansEsc}</span>`;
      }
    });
  }
  function normalizeInput(input){
    const out = [];
    const tryStr = v => typeof v === "string" ? v : (v && typeof v.content === "string" ? v.content : (v && typeof v.html === "string" ? v.html : null));
    const tryTags = v => Array.isArray(v?.tags) ? v.tags.map(t=>String(t)) : [];
    (input||[]).forEach((v,i)=>{
      const html = tryStr(v); if (!html) return;
      const val = String(html);
      out.push({ id:(v&&v.id)?String(v.id):uid(), html:val, originalHtml:val, tags:tryTags(v), status:"new", fav:false, createdAt:Date.now()+i });
    });
    return out;
  }
  function filtered(){
    let arr = notes;
    if (view === "new") arr = arr.filter(n => n.status === "new");
    else if (view === "saved") arr = arr.filter(n => n.status === "saved");
    else if (view === "discarded") arr = arr.filter(n => n.status === "discarded");
    if (searchTerm) {
      const q = searchTerm.toLowerCase();
      arr = arr.filter(n => n.html.toLowerCase().includes(q) || n.tags.some(t=>t.toLowerCase().includes(q)));
    }
    return arr;
  }
  function statusClass(s){ if (s==="saved") return "status-saved"; if (s==="discarded") return "status-discarded"; return "status-new"; }
  function statusLabel(s){ return (s||"new").toUpperCase(); }
  const viewLabel = v => ({all:"All", new:"New", saved:"Saved", discarded:"Discarded"})[v] || v;

  const cardsEl = el("#cards");
  function noteToCardHtml(n){
    const nums = getClozeNumbers(n.html);
    if (!uiState[n.id]) uiState[n.id] = { nums, idx:0, hidden:true };
    else uiState[n.id].nums = nums;
    return `
      <article class="card" id="card-${n.id}" data-id="${n.id}">
        <div class="statusBar ${statusClass(n.status)}">
          <div class="statusTitle">${statusLabel(n.status)}</div>
          <div class="clozeTop ${nums.length? "" : "hidden"}">
            <button class="miniBtn" data-action="clozePrev">‚óÄ</button>
            <span class="indicator" data-role="clozeIndicator">${nums.length? ("1/"+nums.length) : ""}</span>
            <button class="miniBtn" data-action="clozeNext">‚ñ∂</button>
          </div>
        </div>
        ${tagsVisible && n.tags.length ? `<div class="meta"><div class="tags">${n.tags.map(t=>`<span class="pill">${escapeHtml(t)}</span>`).join("")}</div></div>` : ""}
        <div class="notehtml"></div>
        <div class="row">
          <button class="btn small" data-action="copy">üìã Copy</button>
          <button class="btn small" data-action="edit">‚úèÔ∏è Edit</button>
          <button class="btn small good" data-action="save">‚≠ê Save</button>
          <button class="btn small bad" data-action="discard">üóëÔ∏è</button>
        </div>
      </article>
    `;
  }
  function renderList(){
    const cur = filtered();
    lastRendered = cur.map(n=>n.id);
    el("#countLabel").textContent = String(cur.length);
    el("#listArea").classList.toggle("hidden", cur.length === 0);
    const hasNotes = notes.length > 0;
    el("#copyAllBtn").style.display = hasNotes ? "" : "none";
    el("#apkgBtn").style.display = hasNotes ? "" : "none";
    el("#jsonExportBtn").style.display = hasNotes ? "" : "none";
    el("#copyDiffBtn").style.display = hasNotes ? "" : "none";
    const discardedCount = notes.filter(n => n.status === "discarded").length;
    el("#discardCountLabel").textContent = String(discardedCount);
    el("#deleteDiscardedBtn").style.display = discardedCount ? "" : "none";
    el("#appendArea").classList.toggle("hidden", notes.length === 0);
    cardsEl.innerHTML = cur.map(noteToCardHtml).join("");
    cur.forEach(n => wireCard(n.id));
    updateToggleTagsBtn();
  }
  function wireCard(id){
    const root = el(`#card-${CSS.escape(id)}`);
    const get = a => root.querySelector(`[data-action="${a}"]`);
    const note = notes.find(x=>x.id===id);
    const htmlBox = root.querySelector(".notehtml");
    const indicator = root.querySelector('[data-role="clozeIndicator"]');
    const nav = root.querySelector('.clozeTop');

    function update(){
      const st = uiState[id];
      const nums = st.nums; const has = nums.length>0;
      if (!has){ htmlBox.innerHTML = trimHtml(note.html); nav.classList.add('hidden'); }
      else {
        const targetNum = nums[st.idx] ?? nums[0];
        htmlBox.innerHTML = renderClozeTarget(note.html, targetNum, st.hidden);
        indicator.textContent = `${(st.idx+1)}/${nums.length}`;
        nav.classList.remove('hidden');
      }
    }
    if (!uiState[id]) uiState[id] = { nums:getClozeNumbers(note.html), idx:0, hidden:true };
    update();

    root.addEventListener("click", e=>{
      lastInteractedCardId = id;
      if (e.target.closest(".row,.btn,.clozeTop")) return;
      uiState[id].hidden = !uiState[id].hidden; update();
    });

    htmlBox.addEventListener("dblclick", (e) => {
      e.preventDefault(); e.stopPropagation();
      openEditor(note.id, update);
    });

    const prevBtn = root.querySelector('[data-action="clozePrev"]');
    const nextBtn = root.querySelector('[data-action="clozeNext"]');
    if (prevBtn) prevBtn.addEventListener("click", (e)=>{ e.stopPropagation(); const st=uiState[id], n=st.nums.length; if(!n)return; st.idx=(st.idx-1+n)%n; st.hidden=true; update(); });
    if (nextBtn) nextBtn.addEventListener("click", (e)=>{ e.stopPropagation(); const st=uiState[id], n=st.nums.length; if(!n)return; st.idx=(st.idx+1)%n; st.hidden=true; update(); });

    get("copy").addEventListener("click", (e) => { e.stopPropagation(); navigator.clipboard.writeText(note.html).then(()=> toast("Copied")); });
    get("edit").addEventListener("click", (e) => { e.stopPropagation(); openEditor(note.id, update); });

    get("save").addEventListener("click", (e) => {
      e.stopPropagation();
      if (note.status === "saved") { note.status = "new"; note.fav = false; }
      else { note.status = "saved"; note.fav = true; }
      save(); renderList();
    });

    get("discard").addEventListener("click", (e) => {
      e.stopPropagation();
      if (note.status === "discarded") { note.status = "new"; note.fav = false; }
      else { note.status = "discarded"; note.fav = false; }
      save(); if (view === "new") root.classList.add("hidden"); else renderList();
    });
  }

  function toast(msg){
    const b = document.createElement("div");
    b.textContent = msg;
    Object.assign(b.style,{position:"fixed",left:"50%",bottom:"24px",transform:"translateX(-50%)",background:"#111725",color:"#dbe5ff",border:"1px solid #2e3550",padding:"10px 14px",borderRadius:"999px",boxShadow:"var(--shadow)",zIndex:50});
    document.body.appendChild(b);
    setTimeout(()=>{ b.style.transition="all .35s ease"; b.style.opacity="0"; b.style.transform="translateX(-50%) translateY(10px)"; }, 900);
    setTimeout(()=> b.remove(), 1300);
  }

  function confirmModal(message){
    return new Promise(resolve=>{
      const wrap = document.createElement("div");
      wrap.className = "modalBackdrop";
      wrap.innerHTML = `
        <div class="modal" role="dialog" aria-modal="true" aria-label="Confirm">
          <header class="row"><div class="f1">Confirm</div></header>
          <div class="hr"></div>
          <div class="modalContent">
            <p style="margin:8px 0 16px 0;">${escapeHtml(message)}</p>
            <div class="row">
              <button class="btn" data-cancel>Cancel</button>
              <button class="btn primary" data-ok>Continue</button>
            </div>
          </div>
        </div>`;
      document.body.appendChild(wrap);
      openModalBackdrop(wrap);
      const ok = wrap.querySelector('[data-ok]');
      const cancel = wrap.querySelector('[data-cancel]');
      const done = (val)=>{ closeModalBackdrop(wrap); wrap.remove(); resolve(val); };
      ok.addEventListener('click', ()=>done(true));
      cancel.addEventListener('click', ()=>done(false));
      wrap.addEventListener('click', (e)=>{ if (e.target===wrap) done(false); }, {capture:true});
    });
  }

  function choiceModal({ title = "Select", message = "", options = [], cancelLabel = "Cancel" } = {}){
    return new Promise(resolve => {
      if (!Array.isArray(options) || !options.length) { resolve(null); return; }
      const wrap = document.createElement("div");
      wrap.className = "modalBackdrop";
      const optionsHtml = options.map((opt, idx) => `
        <button class="btn" data-choice="${idx}">${escapeHtml(opt?.label ?? "Option")}</button>
      `).join("");
      wrap.innerHTML = `
        <div class="modal" role="dialog" aria-modal="true" aria-label="${escapeHtml(title)}">
          <header class="row"><div class="f1">${escapeHtml(title)}</div></header>
          <div class="hr"></div>
          <div class="modalContent">
            ${message ? `<p style="margin:8px 0 16px 0;">${escapeHtml(message)}</p>` : ""}
            <div class="row" style="flex-wrap:wrap;">
              ${optionsHtml}
              <button class="btn" data-cancel>${escapeHtml(cancelLabel)}</button>
            </div>
          </div>
        </div>`;
      document.body.appendChild(wrap);
      openModalBackdrop(wrap);
      const done = (val)=>{ closeModalBackdrop(wrap); wrap.remove(); resolve(val); };
      wrap.addEventListener('click', (e)=>{
        if (e.target === wrap) { done(null); }
      }, { capture: true });
      wrap.querySelector('[data-cancel]').addEventListener('click', ()=> done(null));
      options.forEach((opt, idx) => {
        const btn = wrap.querySelector(`[data-choice="${idx}"]`);
        if (btn) btn.addEventListener('click', ()=> done(opt?.value ?? opt));
      });
    });
  }

  function openEditor(id, onSaved){
    const note = notes.find(n=>n.id===id);
    const prev = note.html;
    if (typeof note.originalHtml !== "string") note.originalHtml = prev;
    const area = document.createElement("div");
    area.innerHTML = `
      <div class="modalBackdrop">
        <div class="modal" role="dialog" aria-modal="true">
          <header class="row" style="gap:10px;">
            <div class="f1">Edit Card</div>
            <button class="btn" data-ai style="margin-right:14px;">‚ú® UseAI</button>
            <button class="btn" data-x>Close</button>
            <button class="btn green" data-save>‚≠ê Save</button>
          </header>
          <div class="hr"></div>
          <div class="modalContent">
            <div data-editor-shell>
              <textarea class="input" id="editArea" style="width:100%;min-height:260px;font-size:24px;line-height:1.25">${escapeHtml(prev)}</textarea>
              <!-- Controls -->
              <div class="row" style="margin-top:10px;flex-wrap:wrap;align-items:center">
                <button class="btn blue" data-undo title="Undo (Ctrl+Z)">
                  <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <polyline points="1 4 1 10 7 10"></polyline><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path>
                  </svg>
                </button>
                <button class="btn blue" data-redo title="Redo (Ctrl+Y)">
                  <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <polyline points="23 4 23 10 17 10"></polyline><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
                  </svg>
                </button>
                <button class="btn blue hidden" data-view-original title="View the pre-AI version">View Pre-AI</button>
                <div class="f1"></div>
                <div class="row" id="plusRow" style="gap:6px"></div>
              </div>
              <div class="row" style="margin-top:8px;justify-content:space-between;align-items:center">
                <div class="row" style="gap:8px;align-items:center">
                  <button class="btn" data-paste title="Paste from clipboard">Paste</button>
                  <button class="btn hidden" data-addHint title="Add ::hint to current cloze">::hint</button>
                </div>
                <div class="row" style="gap:10px;align-items:center">
                  <button class="btn red" data-removeAll>Remove All Clozes</button>
                  <div class="row" id="minusRow" style="gap:6px"></div>
                </div>
              </div>
            </div>

            <div class="briefOverlay hidden" data-brief-overlay>
              <div>
                <div class="mutedLabel" data-brief-primary-label>Concise version</div>
                <div class="briefCard" data-brief-primary></div>
              </div>
              <div>
                <div class="mutedLabel" data-brief-secondary-label>Original</div>
                <div class="briefCard" data-brief-secondary></div>
              </div>
              <div class="row">
                <div class="f1"></div>
                <button class="btn" data-brief-accept>Use Concise Version</button>
                <button class="btn" data-brief-reject>Keep Current</button>
              </div>
            </div>
          </div>
        </div>
      </div>
    `;
    document.body.appendChild(area);
    const backdrop = area.firstElementChild;
    const ta = area.querySelector("#editArea");
    const aiBtn = area.querySelector("[data-ai]");
    const editorShell = area.querySelector("[data-editor-shell]");
    const briefOverlay = area.querySelector("[data-brief-overlay]");
    const briefPrimaryLabel = area.querySelector("[data-brief-primary-label]");
    const briefSecondaryLabel = area.querySelector("[data-brief-secondary-label]");
    const briefPrimary = area.querySelector("[data-brief-primary]");
    const briefSecondary = area.querySelector("[data-brief-secondary]");
    const briefAccept = area.querySelector("[data-brief-accept]");
    const briefReject = area.querySelector("[data-brief-reject]");
    const viewOriginalBtn = area.querySelector("[data-view-original]");
    
    // Immediate show & sync focus for mobile keyboard
    openModalBackdrop(backdrop);
    ta.focus({ preventScroll: true });
    // Cursor to end
    ta.setSelectionRange(ta.value.length, ta.value.length);

    let closingEditor = false;
    const history = [ta.value];
    let historyIndex = 0;
    let lastInputType = null;
    let lastInputTime = 0;
    const MERGE_WINDOW = 1000;

    const resetMergeState = () => {
      lastInputType = null;
      lastInputTime = 0;
    };

    const recordChange = (newValue, { merge = false } = {}) => {
      if (history[historyIndex] === newValue) return;
      const atEnd = historyIndex === history.length - 1;
      const merging = merge && atEnd;
      if (merging) {
        history[historyIndex] = newValue;
      } else {
        if (!atEnd) history.splice(historyIndex + 1);
        history.push(newValue);
        historyIndex = history.length - 1;
      }
      if (!merging) resetMergeState();
    };

    const preAIVersion = note.originalHtml || prev;
    let aiInFlight = false;
    let lastBriefOriginal = preAIVersion;
    let lastBriefSuggestion = "";
    let lastSplitOriginal = preAIVersion;
    let lastSplitCards = [];

    const hideBriefOverlay = () => {
      if (briefOverlay) briefOverlay.classList.add("hidden");
      if (editorShell) editorShell.classList.remove("hidden");
    };

    const showBriefOverlay = ({
      primaryLabel,
      primaryText,
      secondaryLabel,
      secondaryText,
      acceptLabel,
      rejectLabel,
      onAccept,
      onReject,
    }) => {
      if (!briefOverlay || !briefAccept || !briefReject || !editorShell) return;
      if (briefPrimaryLabel) briefPrimaryLabel.textContent = primaryLabel;
      if (briefSecondaryLabel) briefSecondaryLabel.textContent = secondaryLabel;
      if (briefPrimary) briefPrimary.textContent = primaryText;
      if (briefSecondary) briefSecondary.textContent = secondaryText;
      briefAccept.textContent = acceptLabel;
      briefReject.textContent = rejectLabel;
      briefOverlay.classList.remove("hidden");
      editorShell.classList.add("hidden");

      briefAccept.onclick = () => { if (typeof onAccept === "function") onAccept(); };
      briefReject.onclick = () => { if (typeof onReject === "function") onReject(); };
    };

    const showOriginalToggle = () => {
      if (viewOriginalBtn) viewOriginalBtn.classList.remove("hidden");
    };

    const hideOriginalToggle = () => {
      if (viewOriginalBtn) viewOriginalBtn.classList.add("hidden");
    };

    const setAiLoading = (loading, label = "Working...") => {
      aiInFlight = loading;
      if (aiBtn) {
        aiBtn.disabled = loading;
        aiBtn.textContent = loading ? `‚è≥ ${label}` : "‚ú® UseAI";
      }
      if (loading) hideBriefOverlay();
    };

    const applyEditorValue = (value) => {
      ta.value = value;
      recordChange(ta.value);
      rebuildPlusMinusButtons();
      updateHintButton();
      ta.focus({ preventScroll: true });
    };

    const reviewBriefSuggestion = () => {
      showBriefOverlay({
        primaryLabel: "Concise version",
        primaryText: lastBriefSuggestion,
        secondaryLabel: "Original",
        secondaryText: lastBriefOriginal,
        acceptLabel: "Use Concise Version",
        rejectLabel: "Keep Current",
        onAccept: () => {
          applyEditorValue(lastBriefSuggestion);
          hideBriefOverlay();
          showOriginalToggle();
        },
        onReject: () => {
          hideBriefOverlay();
          showOriginalToggle();
        },
      });
    };

    const formatCardForOverlay = (card) => {
      return (card || "").replace(/<br\s*\/?\>/gi, "\n");
    };

    const reviewSplitSuggestion = () => {
      const formatted = Array.isArray(lastSplitCards)
        ? lastSplitCards.map((c, i) => `${i + 1}) ${formatCardForOverlay(c)}`).join("\n\n")
        : "";

      showBriefOverlay({
        primaryLabel: `Generated cards (${lastSplitCards.length})`,
        primaryText: formatted,
        secondaryLabel: "Original",
        secondaryText: formatCardForOverlay(lastSplitOriginal),
        acceptLabel: "Use Multiple Cards",
        rejectLabel: "Keep Current",
        onAccept: () => {
          replaceNoteWithCards(lastSplitCards);
          hideBriefOverlay();
        },
        onReject: () => {
          hideBriefOverlay();
        },
      });
    };

    const reviewPreAIVersion = () => {
      const baseline = lastBriefOriginal || preAIVersion;
      showBriefOverlay({
        primaryLabel: "Current version",
        primaryText: ta.value,
        secondaryLabel: "Pre-AI version",
        secondaryText: baseline,
        acceptLabel: "Revert to Original",
        rejectLabel: "Keep Current",
        onAccept: () => {
          applyEditorValue(baseline);
          hideBriefOverlay();
          hideOriginalToggle();
        },
        onReject: () => {
          hideBriefOverlay();
        },
      });
    };

    const replaceNoteWithCards = (cards) => {
      if (!Array.isArray(cards) || !cards.length) return;
      const idx = notes.findIndex((n) => n.id === note.id);
      if (idx === -1) return;

      const baseCreated = note.createdAt || Date.now();
      const tagCopy = Array.isArray(note.tags) ? [...note.tags] : [];
      const newNotes = cards.map((html, i) => ({
        id: uid(),
        html,
        originalHtml: html,
        tags: tagCopy,
        status: "new",
        fav: false,
        createdAt: baseCreated + i * 0.001,
      }));

      notes.splice(idx, 1, ...newNotes);
      delete uiState[note.id];
      save();
      renderList();
      hideOriginalToggle();
      close();
      toast(`Added ${newNotes.length} card${newNotes.length > 1 ? "s" : ""}`);
    };

    function performUndo() {
      if (historyIndex > 0) {
        historyIndex--;
        ta.value = history[historyIndex];
        rebuildPlusMinusButtons();
        updateHintButton();
        resetMergeState();
      }
    }

    function performRedo() {
      if (historyIndex < history.length - 1) {
        historyIndex++;
        ta.value = history[historyIndex];
        rebuildPlusMinusButtons();
        updateHintButton();
        resetMergeState();
      }
    }

    const editorKeydownHandler = (e) => { if (e.key === "Escape") close(); };
    document.addEventListener('keydown', editorKeydownHandler);

    const close = ()=>{
      closingEditor = true;
      closeModalBackdrop(backdrop);
      area.remove();
      document.removeEventListener('keydown', editorKeydownHandler);
    };
    area.querySelector("[data-x]").onclick = close;
    area.querySelector("[data-undo]").onclick = () => { performUndo(); ta.focus(); };
    area.querySelector("[data-redo]").onclick = () => { performRedo(); ta.focus(); };

    function getNums(text){ return getClozeNumbers(text); }
    function rebuildPlusMinusButtons(){
      const nums = getNums(ta.value);
      const minusRow = area.querySelector("#minusRow");
      const plusRow  = area.querySelector("#plusRow");
      minusRow.innerHTML = ""; plusRow.innerHTML = "";

      nums.forEach(k=>{
        const b = document.createElement("button");
        b.className = "btn red"; b.textContent = `-C${k}`;
        b.title = `Remove all C${k} clozes`;
        b.onclick = ()=> removeCnum(k);
        minusRow.appendChild(b);
      });

      const m = nums.length ? Math.max(...nums) : 0;
      for(let k=1; k<=m+1; k++){
        const b = document.createElement("button");
        b.className = "btn green"; b.textContent = `+C${k}`;
        b.title = `Add selection as C${k}`;
        b.onclick = ()=> addClozeAs(k);
        plusRow.appendChild(b);
      }
    }

    function addClozeAs(k){
      const start = ta.selectionStart, end = ta.selectionEnd;
      if (start === end){ alert("Select text to cloze."); return; }
      const txt = ta.value;
      let sel = txt.slice(start, end);
      let trailingSpace = '';
      if (sel.endsWith(' ') && sel.trim().length > 0) {
        sel = sel.slice(0, -1);
        trailingSpace = ' ';
      }
      const newCloze = `{{c${k}::${sel}}}`;
      ta.value = txt.slice(0, start) + newCloze + trailingSpace + txt.slice(end);
      recordChange(ta.value);
      const pos = start + newCloze.length;
      ta.setSelectionRange(pos, pos);
      rebuildPlusMinusButtons();
      updateHintButton();
      ta.focus();
    }

    function removeAll(){
      ta.value = ta.value.replace(/{{c\d+::([^]*?)(?:::([^]*?))?}}/g, "$1");
      recordChange(ta.value);
      rebuildPlusMinusButtons();
      updateHintButton();
      ta.focus();
    }

    function removeCnum(k){
      let txt = ta.value;
      const reTarget = new RegExp(`{{c${k}::([^]*?)(?:::([^]*?))?}}`,"g");
      txt = txt.replace(reTarget, "$1");
      let n = k+1;
      while (new RegExp(`{{c${n}::`).test(txt)) {
        const re = new RegExp(`{{c${n}::`,'g');
        txt = txt.replace(re, `{{c${n-1}::`);
        n++;
      }
      ta.value = txt;
      recordChange(ta.value);
      rebuildPlusMinusButtons();
      updateHintButton();
      ta.focus();
    }

    function findActiveCloze(){
      const start = ta.selectionStart;
      const end = ta.selectionEnd;
      if (typeof start !== "number" || start !== end) return null;
      const re = /{{c(\d+)::([^]*?)(?:::([^]*?))?}}/g;
      let m;
      while ((m = re.exec(ta.value))) {
        const matchStart = m.index;
        const matchEnd = matchStart + m[0].length;
        if (start > matchStart && start < matchEnd) {
          return { start: matchStart, end: matchEnd, hasHint: !!m[3] };
        }
      }
      return null;
    }

    function updateHintButton(){
      const hintBtn = area.querySelector("[data-addHint]");
      const active = findActiveCloze();
      const visible = !!active && !active.hasHint;
      hintBtn.classList.toggle("hidden", !visible);
    }

    async function pasteFromClipboard(){
      try {
        if (!navigator?.clipboard?.readText) throw new Error("Clipboard API unavailable");
        const text = await navigator.clipboard.readText();
        if (typeof text !== "string" || text.length === 0) return;
        const start = ta.selectionStart ?? ta.value.length;
        const end = ta.selectionEnd ?? start;
        const next = ta.value.slice(0, start) + text + ta.value.slice(end);
        ta.value = next;
        const pos = start + text.length;
        ta.setSelectionRange(pos, pos);
        recordChange(next);
        rebuildPlusMinusButtons();
        updateHintButton();
        ta.focus({ preventScroll: true });
      } catch (err) {
        console.warn("Paste failed", err);
        alert("Clipboard access is blocked. Please paste manually.");
      }
    }

    async function requestSplitCard(cardCount){
      if (!aiBtn || aiInFlight) return;
      const count = parseInt(cardCount, 10);
      if (!count || count < 2 || count > 4) return;

      const current = ta.value.trim();
      if (!current) { alert("Card is empty."); return; }

      lastSplitOriginal = current;
      setAiLoading(true, "Using AI...");
      try {
        const res = await fetch("/split_card", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ text: current, count })
        });
        if (!res.ok) throw new Error(`Server responded with ${res.status}`);
        const data = await res.json();
        const cards = Array.isArray(data?.cards) ? data.cards.filter(Boolean) : [];
        if (!cards.length) throw new Error("Empty response");
        lastSplitCards = cards;
        reviewSplitSuggestion();
      } catch (err) {
        console.error("Split card request failed", err);
        alert("Could not generate multiple cards. Please try again.");
      } finally {
        setAiLoading(false);
      }
    }

    async function requestBrieferCard(){
      if (!aiBtn || aiInFlight) return;
      const current = ta.value.trim();
      if (!current) { alert("Card is empty."); return; }

      lastBriefOriginal = current;
      setAiLoading(true, "Making Brief...");
      try {
        const res = await fetch("/make_brief", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ text: current })
        });
        if (!res.ok) throw new Error(`Server responded with ${res.status}`);
        const data = await res.json();
        const suggestion = (data?.suggestion || "").trim();
        if (!suggestion) throw new Error("Empty suggestion");
        lastBriefSuggestion = suggestion;
        reviewBriefSuggestion();
      } catch (err) {
        console.error("Brief card request failed", err);
        alert("Could not generate a concise version. Please try again.");
      } finally {
        setAiLoading(false);
      }
    }

    async function openAiMenu(){
      if (aiInFlight) return;
      const action = await choiceModal({
        title: "Use AI",
        message: "Choose what you want to do with this card.",
        options: [
          { label: "‚ú® Make Brief", value: "brief" },
          { label: "üß© Make into Multiple Cards", value: "split" },
        ],
        cancelLabel: "Cancel",
      });
      if (!action) return;
      if (action === "brief") {
        requestBrieferCard();
        return;
      }
      if (action === "split") {
        const howMany = await choiceModal({
          title: "Split into how many cards?",
          message: "Choose between 2 and 4 cards.",
          options: [
            { label: "2 cards", value: 2 },
            { label: "3 cards", value: 3 },
            { label: "4 cards", value: 4 },
          ],
          cancelLabel: "Cancel",
        });
        if (howMany) await requestSplitCard(howMany);
      }
    }

    area.querySelector("[data-removeAll]").onclick = removeAll;
    area.querySelector("[data-paste]").onclick = pasteFromClipboard;
    area.querySelector("[data-addHint]").onclick = ()=>{
      const active = findActiveCloze();
      if (!active || active.hasHint) return;
      const insertion = active.end - 2;
      const next = ta.value.slice(0, insertion) + "::" + ta.value.slice(insertion);
      ta.value = next;
      const caret = insertion + 2;
      ta.setSelectionRange(caret, caret);
      recordChange(next);
      rebuildPlusMinusButtons();
      ta.focus({ preventScroll: true });
      updateHintButton();
    };

    if (aiBtn) aiBtn.onclick = () => openAiMenu();
    if (viewOriginalBtn) viewOriginalBtn.onclick = () => reviewPreAIVersion();

    area.querySelector("[data-save]").onclick = ()=>{
      const v = ta.value;
      note.html = v; note.status = "saved"; note.fav = true;
      save();
      uiState[id] = { nums:getClozeNumbers(v), idx:0, hidden:true };
      renderList();
      if (typeof onSaved==="function") onSaved();
      close();
      toast("Saved");
    };

    // Aggressive Focus Retention Logic (Keyboard Keep-Alive)
    const trapFocus = (e) => {
      if (closingEditor) return;
      const t = e.target;
      if (t === ta) return;
      if (t.closest('button, .btn, .segbtn')) return;
      e.preventDefault();
      if (document.activeElement !== ta) {
        ta.focus({ preventScroll: true });
      }
    };
    backdrop.addEventListener('touchstart', trapFocus, { passive: false, capture: true });
    backdrop.addEventListener('mousedown', trapFocus, { capture: true });

    ta.addEventListener('blur', (e) => {
      if (closingEditor) return;
      const related = e.relatedTarget;
      if (related && related.closest('button, .btn, .segbtn')) return;
      setTimeout(() => {
        if (!closingEditor) ta.focus({ preventScroll: true });
      }, 0);
    });

    ta.addEventListener("input", (e) => {
      if (e.isComposing) return;
      const type = e.inputType || "";
      const now = Date.now();
      const groupKey = (() => {
        if (type === "insertText") return "insertText";
        if (type === "deleteContentBackward") return "deleteBack";
        if (type === "deleteContentForward") return "deleteForward";
        return type || "other";
      })();
      const groupable = groupKey === "insertText" || groupKey === "deleteBack" || groupKey === "deleteForward";
      const shouldMerge = groupable && lastInputType === groupKey && (now - lastInputTime) <= MERGE_WINDOW;
      recordChange(ta.value, { merge: shouldMerge });
      if (groupable) {
        lastInputType = groupKey;
        lastInputTime = now;
      } else {
        resetMergeState();
      }
      rebuildPlusMinusButtons();
      updateHintButton();
    });

    ta.addEventListener("keydown", (e)=>{
      const key = e.key.toLowerCase();
      if (e.altKey && key === 'c') {
        e.preventDefault();
        removeAll();
      }
      else if (e.altKey && key >= '1' && key <= '9') {
        e.preventDefault();
        const k = parseInt(key, 10);
        if (getNums(ta.value).includes(k)) removeCnum(k);
      }
      else if (!e.altKey && !e.ctrlKey && !e.metaKey && key >= '1' && key <= '9') {
        if (ta.selectionStart !== ta.selectionEnd) {
          e.preventDefault();
          addClozeAs(parseInt(key, 10));
        }
      }
      else if (!e.altKey && !e.ctrlKey && !e.metaKey && key === 'enter') {
        e.preventDefault();
        const start = ta.selectionStart;
        const end = ta.selectionEnd;
        const before = ta.value.slice(0, start);
        const after = ta.value.slice(end);
        const insert = "<br>";
        ta.value = before + insert + after;
        const pos = start + insert.length;
        ta.setSelectionRange(pos, pos);
        recordChange(ta.value);
        rebuildPlusMinusButtons();
      }
      else if (e.ctrlKey || e.metaKey) {
        if (key === 'z' && !e.shiftKey) {
          resetMergeState();
          e.preventDefault(); performUndo();
        } else if (key === 'y' || (key === 'z' && e.shiftKey)) {
          resetMergeState();
          e.preventDefault(); performRedo();
        }
      } else if (["arrowleft","arrowright","arrowup","arrowdown","home","end","pageup","pagedown"].includes(key)) {
        resetMergeState();
      }
    });

    ta.addEventListener("mousedown", resetMergeState);
    ta.addEventListener("mouseup", resetMergeState);
    ta.addEventListener("blur", resetMergeState);

    ["keyup","mouseup","select"].forEach(evt => ta.addEventListener(evt, updateHintButton));
    updateHintButton();

    rebuildPlusMinusButtons();
    
    // Safety backup focus
    setTimeout(() => { if (!closingEditor) ta.focus({ preventScroll: true }); }, 150);
  }
  // Solo view

  const soloBack = el("#soloBack");
  const soloCard = el("#soloCard");
  let soloState = { idx:0, hidden:true, nums:[] };
  function drawSolo(){
    const cur = filtered(); if (!cur || !cur[soloIndex]) return;
    const n = cur[soloIndex];
    const nums = soloState.nums = getClozeNumbers(n.html);
    const target = nums[soloState.idx] || null;
    const body = nums.length ? renderClozeTarget(n.html, target, soloState.hidden) : trimHtml(n.html);
    soloCard.innerHTML = `
      <div class="statusBar ${statusClass(n.status)}">
        <div class="statusTitle">${statusLabel(n.status)}</div>
        <div class="clozeTop ${nums.length? "" : "hidden"}">
          <button class="miniBtn" id="soloClozePrev">‚óÄ</button>
          <span class="indicator" id="soloIndicator">${nums.length? (soloState.idx+1)+"/"+nums.length : ""}</span>
          <button class="miniBtn" id="soloClozeNext">‚ñ∂</button>
        </div>
      </div>
      ${tagsVisible && n.tags.length ? `<div class="meta"><div class="tags">${n.tags.map(t=>`<span class="pill">${t}</span>`).join("")}</div></div>` : ""}
      <div class="notehtml" id="soloHtml">${body}</div>
    `;
    const soloHtml = soloCard.querySelector("#soloHtml");
    soloHtml.onclick = ()=>{ soloState.hidden = !soloState.hidden; drawSolo(); };
    soloHtml.addEventListener("dblclick", (e) => {
      e.preventDefault();
      el("#soloEdit").click();
    });

    const prevBtn = soloCard.querySelector("#soloClozePrev");
    const nextBtn = soloCard.querySelector("#soloClozeNext");
    if (prevBtn) prevBtn.onclick = ()=>{ if (!nums.length) return; soloState.idx=(soloState.idx-1+nums.length)%nums.length; soloState.hidden=true; drawSolo(); };
    if (nextBtn) nextBtn.onclick = ()=>{ if (!nums.length) return; soloState.idx=(soloState.idx+1)%nums.length; soloState.hidden=true; drawSolo(); };
  }
  function openSolo(index=0){
    const cur = filtered(); if (!cur.length) return;
    soloIndex = Math.max(0, Math.min(index, cur.length-1));
    soloState.idx = 0; soloState.hidden = true;
    drawSolo();
    openModalBackdrop(soloBack);
  }
  function closeSolo(){ closeModalBackdrop(soloBack); renderList(); }

  // Export helpers
  function visibleNotes(){
    const ids = new Set(lastRendered);
    return notes.filter(n => ids.has(n.id));
  }
  function editedNotes(){
    return notes.filter(n => {
      if (!n || typeof n.html !== "string") return false;
      const baseline = typeof n.originalHtml === "string" ? n.originalHtml : n.html;
      return n.html !== baseline;
    });
  }
  function combinedJson(){
    return notes.map(n => ({
      html: n.html,
      tags: Array.isArray(n.tags) ? n.tags : [],
      id: n.id,
      status: n.status
    }));
  }
  function downloadBlob(filename, blob){
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob); a.download = filename; a.click();
    URL.revokeObjectURL(a.href);
  }

  // Toggle tags UI
  function updateToggleTagsBtn(){
    const b = el("#toggleTagsBtn");
    if (!b) return;
    b.textContent = tagsVisible ? "Hide Tags" : "Show Tags";
  }
  el("#toggleTagsBtn").addEventListener("click", ()=>{
    tagsVisible = !tagsVisible;
    try { localStorage.setItem(tagsKey, tagsVisible ? "1" : "0"); } catch {}
    renderList();
  });

    // Wire UI
    if (notes.length){ el("#ingest").classList.add("hidden"); el("#listArea").classList.remove("hidden"); el("#appendArea").classList.remove("hidden"); el("#copyAllBtn").style.display=""; el("#apkgBtn").style.display=""; el("#jsonExportBtn").style.display=""; el("#copyDiffBtn").style.display=""; }
  renderList();

  els(".segbtn").forEach(b=>{
    if (b.parentElement.getAttribute("aria-label")!=="Views") return;
    b.addEventListener("click", ()=>{
      els('.seg[aria-label="Views"] .segbtn').forEach(x=>x.classList.remove("active"));
      b.classList.add("active"); view = b.dataset.view; renderList();
    });
  });

  el("#search").addEventListener("input", e=>{ searchTerm = e.target.value.trim(); renderList(); });

  el("#loadBtn").addEventListener("click", ()=>{
    let parsed; try { parsed = JSON.parse(el("#jsonInput").value); } catch { alert("Invalid JSON"); return; }
    const normalized = normalizeInput(parsed);
    if (!normalized.length){ alert("No valid cards found."); return; }
    notes = normalized; save();
    el("#ingest").classList.add("hidden");
    el("#listArea").classList.remove("hidden");
    el("#appendArea").classList.remove("hidden");
    el("#copyAllBtn").style.display=""; el("#apkgBtn").style.display=""; el("#jsonExportBtn").style.display=""; el("#copyDiffBtn").style.display="";
    renderList(); toast("Loaded");
  });

  el("#appendBtn").addEventListener("click", ()=>{
    let parsed; try { parsed = JSON.parse(el("#appendInput").value); } catch { alert("Invalid JSON"); return; }
    const normalized = normalizeInput(parsed);
    if (!normalized.length){ alert("No valid cards found to append."); return; }
    const ids = new Set(notes.map(n=>n.id));
    normalized.forEach(n=>{ if (ids.has(n.id)) n.id = uid(); });
    notes = notes.concat(normalized); save();
    el("#appendInput").value = ""; renderList(); toast("Appended");
  });

  el("#copyAllBtn").addEventListener("click", async ()=>{
    const arr = visibleNotes(); if (!arr.length) return alert("Nothing visible to copy.");
    const ok = await confirmModal(`You are about to copy from the "${viewLabel(view)}" view. Continue?`);
    if (!ok) return;
    navigator.clipboard.writeText(arr.map(n=>n.html).join("\n")).then(()=>toast("Copied visible"));
  });

  el("#apkgBtn").addEventListener("click", async ()=>{
    const saved = notes.filter(n => n.status === "saved");
    if (!saved.length) return alert("No saved cards to export.");
    try{
      const res = await fetch("/download_apkg", {
        method:"POST", headers:{"Content-Type":"application/json"},
        body: JSON.stringify({
          deck_name: "Saved Cards",
          notes: saved.map(n=>({
            html: n.html,
            tags: Array.isArray(n.tags) ? n.tags : []
          }))
        })
      });
      if (!res.ok) throw new Error("Server error");
      const blob = await res.blob();
      downloadBlob("cards.apkg", blob);
    }catch(e){
      alert("APKG download failed. Is the backend running at /apkg?\n" + e.message);
    }
  });

  el("#jsonExportBtn").addEventListener("click", async ()=>{
    if (!notes.length) { alert("No cards to export."); return; }
    const choice = await choiceModal({
      title: "Export JSON",
      message: "Download the combined cards JSON or copy it to your clipboard.",
      options: [
        { label: "‚¨áÔ∏è Download file", value: "download" },
        { label: "üìã Copy JSON", value: "copy" }
      ],
      cancelLabel: "Cancel"
    });
    if (!choice) return;
    const jsonText = JSON.stringify(combinedJson(), null, 2);
    if (choice === "download") {
      const blob = new Blob([jsonText], { type: "application/json" });
      downloadBlob("cards.json", blob);
      toast("JSON downloaded");
    } else if (choice === "copy") {
      try {
        await navigator.clipboard.writeText(jsonText);
        toast("JSON copied");
      } catch {
        alert("Failed to copy JSON to clipboard.");
      }
    }
  });

  el("#copyDiffBtn").addEventListener("click", ()=>{
    const arr = editedNotes();
    if (!arr.length) { alert("No edited cards to diff."); return; }
    const diffText = arr.map((n, idx) => {
      const baseline = typeof n.originalHtml === "string" ? n.originalHtml : "";
      const header = `Card ${idx+1}: ${n.id || "(no id)"}`;
      const tagLine = n.tags && n.tags.length ? `Tags: ${n.tags.join(", ")}` : "";
      return [
        header,
        tagLine,
        "--- before",
        baseline,
        "+++ after",
        n.html
      ].filter(Boolean).join("\n");
    }).join("\n\n");
    navigator.clipboard.writeText(diffText).then(()=>toast("Copied diff")).catch(()=>alert("Failed to copy diff to clipboard."));
  });

  el("#nukeBtn").addEventListener("click", ()=>{
    if (!confirm("Clear local data and start over?")) return;
    localStorage.removeItem(storeKey);
    notes = []; renderList();
    el("#listArea").classList.add("hidden"); el("#appendArea").classList.add("hidden");
    el("#ingest").classList.remove("hidden");
    el("#copyAllBtn").style.display="none"; el("#apkgBtn").style.display="none"; el("#jsonExportBtn").style.display="none"; el("#copyDiffBtn").style.display="none";
    el("#deleteDiscardedBtn").style.display="none";
  });

  el("#deleteDiscardedBtn").addEventListener("click", ()=>{
    const discardedIds = notes.filter(n => n.status === "discarded").map(n => n.id);
    if (!discardedIds.length) { toast("No discarded cards to delete."); return; }
    if (!confirm("Delete all discarded cards? This cannot be undone.")) return;
    const removeSet = new Set(discardedIds);
    notes = notes.filter(n => !removeSet.has(n.id));
    discardedIds.forEach(id => delete uiState[id]);
    save();
    renderList();
    toast("Discarded cards deleted");
  });

  // Solo controls
  el("#soloBtn").addEventListener("click", ()=> openSolo(0));
  el("#soloClose").addEventListener("click", closeSolo);
  el("#soloPrev").addEventListener("click", ()=> { if (soloIndex>0){ soloIndex--; drawSolo(); } });
  el("#soloNext").addEventListener("click", ()=> { const m=filtered().length-1; if (soloIndex<m){ soloIndex++; drawSolo(); } });
  el("#soloCopy").addEventListener("click", ()=> { const cur = filtered()[soloIndex]; navigator.clipboard.writeText(cur.html).then(()=>toast("Copied")); });
  el("#soloEdit").addEventListener("click", ()=>{
    const cur = filtered()[soloIndex]; if (!cur) return;
    openEditor(cur.id, ()=>{ drawSolo(); });
  });

  el("#soloSave").addEventListener("click", ()=>{
     const cur=filtered()[soloIndex]; if (!cur) return;
    if (cur.status === "saved") { cur.status = "new"; cur.fav = false; }
    else { cur.status = "saved"; cur.fav = true; }
    save(); renderList(); drawSolo();
  });
  el("#soloDiscard").addEventListener("click", ()=>{
    const cur=filtered()[soloIndex]; if (!cur) return;
    if (cur.status === "discarded") { cur.status = "new"; cur.fav = false; }
    else { cur.status = "discarded"; cur.fav = false; }
    save(); renderList(); drawSolo();
  });

  window.addEventListener("keydown", (e)=>{
    if (el("#soloBack").style.display==="flex"){
      if (e.key==="Escape"){ closeSolo(); }
      else if (e.key==="ArrowLeft"){ el("#soloPrev").click(); }
      else if (e.key==="ArrowRight"){ el("#soloNext").click(); }
      else if (e.key===" "){ e.preventDefault(); const body = el("#soloCard #soloHtml"); if (body) body.click(); }
      else if (e.key.toLowerCase()==="s"){ el("#soloSave").click(); }
      else if (e.key.toLowerCase()==="d"){ el("#soloDiscard").click(); }
      else if (e.key.toLowerCase()==="e"){ el("#soloEdit").click(); }
      else if (e.key.toLowerCase()==="c"){ el("#soloCopy").click(); }
    }
  });

  // Global card shortcuts (E, D, S, C)
  window.addEventListener("keydown", (e) => {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.closest('.modal')) return;
    if (lastInteractedCardId) {
      const key = e.key.toLowerCase();
      const cardEl = el(`#card-${CSS.escape(lastInteractedCardId)}`);
      if (!cardEl) return;
      const actions = { e: 'edit', d: 'discard', s: 'save', c: 'copy' };
      const action = actions[key];
      if (action) {
        e.preventDefault();
        const button = cardEl.querySelector(`[data-action="${action}"]`);
        if (button) button.click();
      }
    }
  });

  el("#soloBack").addEventListener("click", (e)=>{ if (e.target===el("#soloBack")) closeSolo(); });

  // üîÅ Keep-alive ping every ~10s to prevent Render free dyno sleep
  setInterval(() => { fetch("/ping").catch(()=>{}); }, 10000);
})();
</script>
</body>
</html>